<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìë™ í† í´ë¡œì§€ ë§ˆì¸ë“œë§µ</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .title {
            font-size: 28px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 16px;
        }
        
        .control-panel {
            background: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .button {
            background: #007acc;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s;
        }
        
        .button:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }
        
        .button-success {
            background: #28a745;
        }
        
        .button-success:hover {
            background: #1e7e34;
        }
        
        .button-danger {
            background: #dc3545;
        }
        
        .topology-canvas {
            background: #f8fdf8;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            position: relative;
            height: 1200px;
            overflow: hidden;
        }
        
        .node {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            user-select: none;
        }
        
        .node:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        .center-node {
            width: 120px;
            height: 120px;
            background: #000;
            color: white;
            font-size: 16px;
            z-index: 5;
            border: 4px solid #333;
        }
        
        .person-node {
            width: 100px;
            height: 100px;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            border: 3px solid rgba(255,255,255,0.3);
            line-height: 1.2;
            word-break: keep-all;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 5px;
        }
        
        .node-info {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 20;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 600px;
            min-width: 300px;
            white-space: normal;
            word-wrap: break-word;
        }
        
        .node:hover .node-info {
            opacity: 1;
        }
        
        .connection-line {
            position: absolute;
            height: 2px;
            background: rgba(0,0,0,0.2);
            transform-origin: left center;
            z-index: 1;
            transition: all 0.3s;
        }
        
        .connection-line:hover {
            background: rgba(0,0,0,0.4);
            height: 3px;
        }
        
        .cluster-controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .cluster-toggle {
            display: inline-block;
            padding: 8px 16px;
            margin: 5px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }
        
        .cluster-toggle.active {
            background: #007acc;
            transform: scale(1.05);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .stat-number {
            font-size: 32px;
            font-weight: bold;
            color: #007acc;
        }
        
        .stat-label {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .alert {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid;
        }
        
        .alert-info {
            background: #d1ecf1;
            border-color: #17a2b8;
            color: #0c5460;
        }
        
        .alert-success {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }
        
        .color-red { 
            background: linear-gradient(135deg, #ffb3b3 0%, #ff8080 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-yellow { 
            background: linear-gradient(135deg, #fff2b3 0%, #ffe680 100%);
            color: #555; 
            text-shadow: none;
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-blue { 
            background: linear-gradient(135deg, #b3d9ff 0%, #80c4ff 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-green { 
            background: linear-gradient(135deg, #b3f0b3 0%, #80e680 100%);
            color: #333; 
            text-shadow: none;
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-purple { 
            background: linear-gradient(135deg, #e6b3ff 0%, #d580ff 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-orange { 
            background: linear-gradient(135deg, #ffd9b3 0%, #ffbf80 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-pink { 
            background: linear-gradient(135deg, #ffb3e6 0%, #ff80d5 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-cyan { 
            background: linear-gradient(135deg, #b3f0ff 0%, #80e6ff 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        
        .loading {
            text-align: center;
            color: #007acc;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">ğŸ§  ìë™ í† í´ë¡œì§€ ë§ˆì¸ë“œë§µ</div>
            <div class="subtitle">ë¶ìŠ¤í„°ë”” ë°ì´í„°ê°€ ìë™ìœ¼ë¡œ ì‹œê°í™”ë©ë‹ˆë‹¤</div>
        </div>
        
        <div class="stats" id="statsContainer">
            <div class="stat-card">
                <div class="stat-number" id="responseCount">0</div>
                <div class="stat-label">ì´ ì‘ë‹µ</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="keywordCount">0</div>
                <div class="stat-label">í‚¤ì›Œë“œ</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="clusterCount">0</div>
                <div class="stat-label">í´ëŸ¬ìŠ¤í„°</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="centerConcept">-</div>
                <div class="stat-label">ì¤‘ì‹¬ ê°œë…</div>
            </div>
        </div>
        
        <div class="control-panel">
            <h3>ğŸ“Š ë°ì´í„° ìƒíƒœ</h3>
            <div class="alert alert-info">
                <strong>ìë™ ì—…ë°ì´íŠ¸:</strong> êµ¬ê¸€ ìŠ¤í”„ë ˆë“œì‹œíŠ¸ì—ì„œ 5ë¶„ë§ˆë‹¤ ìë™ ë™ê¸°í™”ë©ë‹ˆë‹¤
            </div>
            
            <div>
                <button class="button button-success" onclick="loadAutoData()">ğŸ”„ ìµœì‹  ë°ì´í„° ë¡œë“œ</button>
                <button class="button" onclick="loadSampleData()">ğŸ“ ìƒ˜í”Œ ë°ì´í„° ë³´ê¸°</button>
                <button class="button" onclick="togglePhysics()" id="physicsToggle">ğŸŸ ë¬¼ë¦¬ OFF</button>
                <button class="button button-danger" onclick="clearAll()">ğŸ—‘ï¸ í™”ë©´ ì§€ìš°ê¸°</button>
                <button class="button" onclick="exportImage()">ğŸ“¸ ì´ë¯¸ì§€ ì €ì¥</button>
            </div>
        </div>
        
        <div class="cluster-controls" id="clusterControls" style="display: none;">
            <h3>ğŸ›ï¸ í´ëŸ¬ìŠ¤í„° í† ê¸€</h3>
            <div id="clusterButtons"></div>
        </div>
        
        <div class="topology-canvas" id="topologyCanvas">
            <div class="loading">
                <h3>ğŸ“¡ ë¶ìŠ¤í„°ë”” ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</h3>
                <p>ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”</p>
            </div>
        </div>
    </div>

    <script>
        let currentData = null;
        let visibleClusters = new Set();
        let physicsNodes = [];
        let magneticStones = []; // ğŸª¨ ë³´ì´ì§€ ì•ŠëŠ” ìì„ ëŒë“¤
        let lastSnapTime = 0; // âš¡ ë§ˆì§€ë§‰ ë°˜ì§ ê·€í™˜ ì‹œê°„
        let animationId = null;
        let isPhysicsEnabled = false;
        let previousRankings = {};
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ìœ¼ë¡œ ë°ì´í„° ë¡œë“œ
        window.addEventListener('DOMContentLoaded', function() {
            loadAutoData();
        });
        
        async function loadAutoData() {
            try {
                showAlert('info', 'ìµœì‹  ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...');
                
                // GitHubì—ì„œ book_study_data.txt íŒŒì¼ ì½ê¸° (ìºì‹œ ë°©ì§€)
                const cacheBuster = new Date().getTime();
                const response = await fetch(`./book_study_data.txt?v=${cacheBuster}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvData = await response.text();
                
                if (!csvData.trim()) {
                    throw new Error('ë°ì´í„° íŒŒì¼ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
                }
                
                // TSVë¥¼ CSVë¡œ ë³€í™˜ (íƒ­ì„ ì‰¼í‘œë¡œ)
                const csvConverted = csvData.replace(/\t/g, ',');
                
                // ë°ì´í„° ë¶„ì„ ë° ì‹œê°í™” (ì˜¤ë¥˜ ë°©ì§€ ê°•í™”)
                const result = analyzeCSVDataSafely(csvConverted);
                
                if (!result || !result.clusters || result.clusters.length === 0) {
                    throw new Error('ìœ íš¨í•œ í´ëŸ¬ìŠ¤í„° ë°ì´í„°ê°€ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                }
                
                renderTopologyVisualization(result);
                updateStats(result);
                setupClusterControls(result);
                currentData = result;
                
                document.getElementById('clusterControls').style.display = 'block';
                
                showAlert('success', `ìë™ ë¡œë“œ ì™„ë£Œ! ${result.responses.length}ê°œ ì‘ë‹µ, ${result.clusters.length}ê°œ í´ëŸ¬ìŠ¤í„°ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                
            } catch (error) {
                console.error('ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
                showAlert('error', `ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: ${error.message}. ìƒ˜í”Œ ë°ì´í„°ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.`);
                loadSampleData();
            }
        }
        
        // ì•ˆì „í•œ ë°ì´í„° ë¶„ì„ í•¨ìˆ˜ (ì˜¤ë¥˜ ë°©ì§€ ê°•í™”)
        function analyzeCSVDataSafely(csvData) {
            try {
                const lines = csvData.trim().split('\n');
                const responses = [];
                
                // ìµœì†Œ 2ì¤„ ì´ìƒ ìˆì–´ì•¼ í•¨ (í—¤ë” + ë°ì´í„°)
                if (lines.length < 2) {
                    console.warn('ë°ì´í„°ê°€ ë„ˆë¬´ ì ìŠµë‹ˆë‹¤. ìƒ˜í”Œ ë°ì´í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.');
                    return null;
                }
                
                // CSV íŒŒì‹± - ì˜¤ë¥˜ ë°©ì§€ ê°•í™”
                for (let i = 1; i < lines.length; i++) {
                    try {
                        const values = parseCSVLine(lines[i]);
                        
                        // ìµœì†Œ ì¡°ê±´ í™•ì¸ (Bì—´ ì´ë¦„, Cì—´ ë‚´ìš© ì¤‘ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ ìœ íš¨)
                        if (values.length >= 2) {
                            const name = values[1] ? values[1].replace(/"/g, '').trim() : '';
                            const cColumnRaw = values[2] ? values[2].replace(/"/g, '').trim() : '';
                            
                            // ìœ íš¨í•œ ë°ì´í„°ë§Œ ì¶”ê°€
                            if (name || cColumnRaw) {
                                const response = {
                                    name: name || `ì‘ë‹µì${i}`,
                                    keywords: cColumnRaw ? cColumnRaw.split(/[,\s]+/).filter(k => k.trim()) : ['ê¸°íƒ€'],
                                    summary: values[3] ? values[3].replace(/"/g, '').trim() : '',
                                    interpretation: values[4] ? values[4].replace(/"/g, '').trim() : '',
                                    cColumnData: cColumnRaw || 'ë‚´ìš© ì—†ìŒ'
                                };
                                responses.push(response);
                            }
                        }
                    } catch (rowError) {
                        console.warn(`í–‰ ${i} íŒŒì‹± ì˜¤ë¥˜:`, rowError);
                        continue; // í•´ë‹¹ í–‰ë§Œ ê±´ë„ˆë›°ê³  ê³„ì† ì§„í–‰
                    }
                }
                
                console.log(`íŒŒì‹± ì™„ë£Œ: ${responses.length}ê°œ ì‘ë‹µ ì²˜ë¦¬ë¨`);
                
                if (responses.length === 0) {
                    console.warn('ìœ íš¨í•œ ì‘ë‹µì´ ì—†ìŠµë‹ˆë‹¤.');
                    return null;
                }
                
                // í´ëŸ¬ìŠ¤í„°ë§ (ì˜¤ë¥˜ ë°©ì§€)
                const clusters = performAutomaticClusteringSafely(responses);
                
                if (!clusters || clusters.length === 0) {
                    console.warn('í´ëŸ¬ìŠ¤í„° ìƒì„± ì‹¤íŒ¨');
                    return null;
                }
                
                // ì¢Œí‘œ ê³„ì‚°
                const coordinates = calculateAutoCoordinates(clusters);
                
                // ì¤‘ì‹¬ ê°œë… ê²°ì •
                const allKeywords = responses.flatMap(r => r.keywords || []);
                const keywordFreq = {};
                allKeywords.forEach(k => {
                    if (k && k.trim()) {
                        keywordFreq[k] = (keywordFreq[k] || 0) + 1;
                    }
                });
                
                const centerConcept = Object.keys(keywordFreq).length > 0 ? 
                    Object.entries(keywordFreq).sort((a, b) => b[1] - a[1])[0]?.[0] : 'ë””ì§€í„¸ì›°ë¹™';
                
                return {
                    responses,
                    clusters,
                    coordinates,
                    centerConcept: 'ë””ì§€í„¸ì›°ë¹™',
                    stats: {
                        totalResponses: responses.length,
                        totalKeywords: Object.keys(keywordFreq).length,
                        clusterCount: clusters.length
                    }
                };
                
            } catch (error) {
                console.error('ë°ì´í„° ë¶„ì„ ì¤‘ ì˜¤ë¥˜:', error);
                return null;
            }
        }
        
        // ìˆœìœ„ ë³€ë™ ê°ì§€ ë° í¬ê¸° ì¡°ì ˆì„ ìœ„í•œ í•¨ìˆ˜
        function detectRankChanges(clusters) {
            const currentRankings = {};
            
            clusters.forEach(cluster => {
                // í˜„ì¬ í´ëŸ¬ìŠ¤í„°ì˜ ë¹ˆë„ìˆ˜ ê¸°ë°˜ ìˆœìœ„ ê³„ì‚°
                const contentFreq = {};
                
                if (cluster.members && Array.isArray(cluster.members)) {
                    cluster.members.forEach(member => {
                        const content = member.cColumnData?.trim();
                        if (content && content.length > 0 && content !== 'ë‚´ìš© ì—†ìŒ') {
                            contentFreq[content] = (contentFreq[content] || 0) + 1;
                        }
                    });
                }
                
                // ë¹ˆë„ìˆ˜ ê¸°ì¤€ ì •ë ¬í•˜ì—¬ í˜„ì¬ ìˆœìœ„ ìƒì„±
                const sortedContents = Object.entries(contentFreq)
                    .sort((a, b) => b[1] - a[1]);
                
                // ê° ë‚´ìš©ë³„ í˜„ì¬ ìˆœìœ„ ì €ì¥
                sortedContents.forEach(([content, frequency], index) => {
                    const key = `${cluster.name}:${content}`;
                    currentRankings[key] = {
                        rank: index + 1,
                        frequency: frequency,
                        cluster: cluster.name
                    };
                });
            });
            
            // ìˆœìœ„ ë³€ë™ ê³„ì‚°
            const rankChanges = {};
            
            Object.keys(currentRankings).forEach(key => {
                const current = currentRankings[key];
                const previous = previousRankings[key];
                
                if (previous) {
                    // ì´ì „ ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš° ìˆœìœ„ ë³€ë™ ê³„ì‚°
                    if (current.rank > previous.rank) {
                        // ìˆœìœ„ê°€ ë–¨ì–´ì§ (ìˆ«ìê°€ ì»¤ì§ = ìˆœìœ„ í•˜ë½)
                        rankChanges[key] = {
                            type: 'down',
                            previousRank: previous.rank,
                            currentRank: current.rank,
                            sizeMultiplier: 0.8 // -20% í¬ê¸°
                        };
                    } else if (current.rank < previous.rank) {
                        // ìˆœìœ„ê°€ ì˜¬ë¼ê°
                        rankChanges[key] = {
                            type: 'up',
                            previousRank: previous.rank,
                            currentRank: current.rank,
                            sizeMultiplier: 1.0 // ì›ë˜ í¬ê¸° ìœ ì§€
                        };
                    } else {
                        // ìˆœìœ„ ë™ì¼
                        rankChanges[key] = {
                            type: 'same',
                            previousRank: previous.rank,
                            currentRank: current.rank,
                            sizeMultiplier: 1.0 // ì›ë˜ í¬ê¸° ìœ ì§€
                        };
                    }
                } else {
                    // ìƒˆë¡œ ë“±ì¥í•œ ë‚´ìš©
                    rankChanges[key] = {
                        type: 'new',
                        previousRank: null,
                        currentRank: current.rank,
                        sizeMultiplier: 1.0 // ì›ë˜ í¬ê¸°
                    };
                }
            });
            
            // ì´ì „ ìˆœìœ„ ì—…ë°ì´íŠ¸
            previousRankings = { ...currentRankings };
            
            console.log('ìˆœìœ„ ë³€ë™ ê°ì§€:', rankChanges);
            return rankChanges;
        }

        function performAutomaticClusteringSafely(responses) {
            try {
                const clusterSeeds = [
                    { name: "í™˜ê²½ì„¤ê³„", keywords: ["ë¬¼ë¦¬ì í™˜ê²½", "ê³µê°„ë°°ì¹˜", "íŠ¸ë¦¬ê±°ì„¤ì •", "í™˜ê²½ë””ìì¸"], color: "red" },
                    { name: "ê°œì¸ì„±ì¥", keywords: ["ì •ì²´ì„±", "ìì•„ê°œë°œ", "ë§ˆìŒê°€ì§", "ë‚´ì ë³€í™”", "ì„±ì¥ë§ˆì¸ë“œ"], color: "yellow" },
                    { name: "ì‹œìŠ¤í…œì‚¬ê³ ", keywords: ["ì‹œìŠ¤í…œ", "í”„ë¡œì„¸ìŠ¤", "ì²´ê³„ì ", "êµ¬ì¡°í™”", "ë°©ë²•ë¡ "], color: "blue" },
                    { name: "ì§€ì†ì„±", keywords: ["ë°˜ë³µ", "ë£¨í‹´", "ê¾¸ì¤€í•¨", "ì§€ì†ê°€ëŠ¥", "ì¼ê´€ì„±", "ìŠµê´€í™”"], color: "green" },
                    { name: "ì‚¬íšŒì ê´€ê³„", keywords: ["ê´€ê³„", "ê³µë™ì²´", "ì‚¬íšŒì ì±…ì„", "ë™ë£Œ", "í˜‘ë ¥", "ë„¤íŠ¸ì›Œí¬"], color: "purple" },
                    { name: "ì ì§„ì ë³€í™”", keywords: ["ì‘ì€ë³€í™”", "ë³µë¦¬íš¨ê³¼", "ëˆ„ì ", "ë‹¨ê³„ì ", "ì ì§„ì ê°œì„ "], color: "orange" },
                    { name: "ê°ì •ë™ê¸°", keywords: ["ê°ì •", "ë™ê¸°ë¶€ì—¬", "ë§Œì¡±ê°", "ì„±ì·¨ê°", "ìì‹ ê°"], color: "pink" },
                    { name: "ì‹¤ìš©ì ë„êµ¬", keywords: ["ë„êµ¬", "ê¸°ìˆ í™œìš©", "ì•±", "ë””ì§€í„¸ë„êµ¬", "ì‹¤í–‰ë°©ë²•"], color: "cyan" }
                ];
                
                const clusters = [];
                let totalAssigned = 0;
                
                // ëª¨ë“  ì‘ë‹µì„ ìˆœíšŒí•˜ë©° í´ëŸ¬ìŠ¤í„°ì— ë°°ì •
                responses.forEach((response, index) => {
                    try {
                        let bestMatch = { score: 0, cluster: null };
                        
                        // í‚¤ì›Œë“œ ë§¤ì¹­ (ì•ˆì „í•˜ê²Œ)
                        clusterSeeds.forEach(seed => {
                            try {
                                const keywords = response.keywords || [];
                                const matchScore = keywords.filter(keyword => {
                                    if (!keyword || typeof keyword !== 'string') return false;
                                    return seed.keywords.some(seedKeyword => {
                                        if (!seedKeyword || typeof seedKeyword !== 'string') return false;
                                        const kw = keyword.toLowerCase().trim();
                                        const sw = seedKeyword.toLowerCase().trim();
                                        return kw === sw || 
                                               (kw.length > 2 && sw.includes(kw)) ||
                                               (sw.length > 2 && kw.includes(sw));
                                    });
                                }).length;
                                
                                if (matchScore > bestMatch.score) {
                                    bestMatch = { score: matchScore, cluster: seed };
                                }
                            } catch (matchError) {
                                console.warn('ë§¤ì¹­ ì˜¤ë¥˜:', matchError);
                            }
                        });
                        
                        // ë§¤ì¹­ë˜ì§€ ì•Šìœ¼ë©´ ìˆœí™˜ ë°°ì •
                        if (bestMatch.score === 0) {
                            const fallbackIndex = index % clusterSeeds.length;
                            bestMatch.cluster = clusterSeeds[fallbackIndex];
                        }
                        
                        // í´ëŸ¬ìŠ¤í„°ì— ì¶”ê°€
                        let cluster = clusters.find(c => c.name === bestMatch.cluster.name);
                        if (!cluster) {
                            cluster = {
                                name: bestMatch.cluster.name,
                                color: bestMatch.cluster.color,
                                members: [],
                                keywords: []
                            };
                            clusters.push(cluster);
                        }
                        
                        cluster.members.push(response);
                        if (response.keywords) {
                            cluster.keywords.push(...response.keywords);
                        }
                        totalAssigned++;
                        
                    } catch (responseError) {
                        console.warn(`ì‘ë‹µ ${index} ì²˜ë¦¬ ì˜¤ë¥˜:`, responseError);
                    }
                });
                
                console.log(`í´ëŸ¬ìŠ¤í„°ë§ ì™„ë£Œ: ${totalAssigned}ê°œ ë°°ì •, ${clusters.length}ê°œ í´ëŸ¬ìŠ¤í„°`);
                return clusters;
                
            } catch (error) {
                console.error('í´ëŸ¬ìŠ¤í„°ë§ ì˜¤ë¥˜:', error);
                return [];
            }
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }
        
        function calculateAutoCoordinates(clusters) {
            const centerX = 700, centerY = 600;
            const baseRadius = 280;
            const coordinates = [];
            
            // ìˆœìœ„ ë³€ë™ ê°ì§€
            const rankChanges = detectRankChanges(clusters);
            
            // ì¤‘ì‹¬ì  - ë¬¼ë¦¬ ì—”ì§„ ì¤€ë¹„
            coordinates.push({
                name: "ì¤‘ì‹¬ê°œë…",
                x: centerX,
                y: centerY,
                color: "black",
                size: "large",
                type: "center",
                vx: 0, vy: 0,
                mass: 10,
                isCenter: true
            });
            
            // ë¬¼ë¦¬ ê¸°ë°˜ í´ëŸ¬ìŠ¤í„° ë…¸ë“œ ìƒì„±
            clusters.forEach((cluster, clusterIndex) => {
                try {
                    const clusterAngle = (360 / clusters.length) * clusterIndex;
                    
                    const contentFreq = {};
                    const contentAuthors = {};
                    
                    if (cluster.members && Array.isArray(cluster.members)) {
                        cluster.members.forEach((member, memberIndex) => {
                            try {
                                const content = member.cColumnData?.trim();
                                const name = member.name?.trim() || `ì‘ë‹µì${memberIndex + 1}`;
                                
                                if (content && content.length > 0 && content !== 'ë‚´ìš© ì—†ìŒ') {
                                    contentFreq[content] = (contentFreq[content] || 0) + 1;
                                    if (!contentAuthors[content]) {
                                        contentAuthors[content] = [];
                                    }
                                    contentAuthors[content].push(name);
                                }
                            } catch (memberError) {
                                console.warn('ë©¤ë²„ ì²˜ë¦¬ ì˜¤ë¥˜:', memberError);
                            }
                        });
                    }
                    
                    const topContents = Object.entries(contentFreq)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3);
                    
                    for (let nodeIndex = 0; nodeIndex < 3; nodeIndex++) {
                        try {
                            const nodeAngle = clusterAngle + (nodeIndex - 1) * 25;
                            const radius = baseRadius + (nodeIndex === 2 ? 200 : nodeIndex * 60);
                            
                            const x = centerX + Math.cos(nodeAngle * Math.PI / 180) * radius;
                            const y = centerY + Math.sin(nodeAngle * Math.PI / 180) * radius;
                            
                            let displayText, tooltipContent, sizeMultiplier = 1.0;
                            
                            if (topContents[nodeIndex]) {
                                const [content, frequency] = topContents[nodeIndex];
                                const authors = contentAuthors[content] || [];
                                const rankKey = `${cluster.name}:${content}`;
                                
                                if (rankChanges[rankKey]) {
                                    sizeMultiplier = rankChanges[rankKey].sizeMultiplier;
                                    const rankInfo = rankChanges[rankKey];
                                    let rankChangeText = '';
                                    if (rankInfo.type === 'down') {
                                        rankChangeText = `\nğŸ“‰ ìˆœìœ„ ë³€ë™: ${rankInfo.previousRank}ë“± â†’ ${rankInfo.currentRank}ë“± (í•˜ë½)`;
                                    } else if (rankInfo.type === 'up') {
                                        rankChangeText = `\nğŸ“ˆ ìˆœìœ„ ë³€ë™: ${rankInfo.previousRank}ë“± â†’ ${rankInfo.currentRank}ë“± (ìƒìŠ¹)`;
                                    } else if (rankInfo.type === 'new') {
                                        rankChangeText = `\nğŸ†• ì‹ ê·œ ë“±ì¥: ${rankInfo.currentRank}ë“±`;
                                    }
                                    
                                    const words = content.split(' ').filter(w => w.trim()).slice(0, 3);
                                    displayText = words.length > 0 ? words.join(' ') : 
                                                (content.length > 15 ? content.substring(0, 15) + '...' : content);
                                    
                                    const uniqueAuthors = [...new Set(authors)];
                                    const authorsList = uniqueAuthors.slice(0, 3).join(', ') + 
                                                      (uniqueAuthors.length > 3 ? ' ...' : '');
                                    
                                    tooltipContent = `${content}\n\nì‘ì„±ì: ${authorsList}\në¹ˆë„: ${frequency}íšŒ${rankChangeText}`;
                                } else {
                                    const words = content.split(' ').filter(w => w.trim()).slice(0, 3);
                                    displayText = words.length > 0 ? words.join(' ') : 
                                                (content.length > 15 ? content.substring(0, 15) + '...' : content);
                                    
                                    const uniqueAuthors = [...new Set(authors)];
                                    const authorsList = uniqueAuthors.slice(0, 3).join(', ') + 
                                                      (uniqueAuthors.length > 3 ? ' ...' : '');
                                    
                                    tooltipContent = `${content}\n\nì‘ì„±ì: ${authorsList}\në¹ˆë„: ${frequency}íšŒ\nğŸ”„ ì´ˆê¸° ë°ì´í„°`;
                                }
                            } else {
                                displayText = `${cluster.name} ${nodeIndex + 1}`;
                                tooltipContent = `${cluster.name} í´ëŸ¬ìŠ¤í„°\nìˆœìœ„ ${nodeIndex + 1} - ë°ì´í„° ë¶€ì¡±`;
                            }
                            
                            coordinates.push({
                                name: displayText,
                                x: Math.max(50, Math.min(1350, x)),
                                y: Math.max(50, Math.min(1150, y)),
                                color: cluster.color,
                                size: "medium",
                                type: "person",
                                cluster: cluster.name,
                                keywords: (cluster.keywords || []).slice(0, 5).join(", "),
                                summary: "",
                                cColumnData: tooltipContent,
                                nodeType: "frequency-based",
                                rank: nodeIndex + 1,
                                sizeMultiplier: sizeMultiplier,
                                vx: 0, vy: 0,
                                mass: 3 - nodeIndex,
                                parentCluster: clusterIndex,
                                nodeIndex: nodeIndex,
                                targetRadius: radius,
                                isCenter: false
                            });
                        } catch (nodeError) {
                            console.warn(`ë…¸ë“œ ${nodeIndex} ìƒì„± ì˜¤ë¥˜:`, nodeError);
                        }
                    }
                } catch (clusterError) {
                    console.warn(`í´ëŸ¬ìŠ¤í„° ${clusterIndex} ì²˜ë¦¬ ì˜¤ë¥˜:`, clusterError);
                }
            });
            
            return coordinates;
        }
        
        function renderTopologyVisualization(data) {
            const canvas = document.getElementById('topologyCanvas');
            canvas.innerHTML = '';
            
            physicsNodes = [...data.coordinates];
            
            // ğŸª¨ ê° ë…¸ë“œì˜ ëª©ì ì§€ì— ë³´ì´ì§€ ì•ŠëŠ” ìì„ ëŒ ìƒì„±
            magneticStones = [];
            physicsNodes.forEach(node => {
                if (!node.isCenter) {
                    magneticStones.push({
                        targetX: node.x, // ì›ë˜ ëª©ì ì§€ ì¢Œí‘œ
                        targetY: node.y,
                        donutRadius: 25,  // ë„ë„› ë°˜ì§€ë¦„ (ë°€ì–´ë‚´ëŠ” ì˜ì—­)
                        coreRadius: 8,    // ì¤‘ì‹¬ ë°˜ì§€ë¦„ (ëŒì–´ë‹¹ê¸°ëŠ” ì˜ì—­)
                        pushForce: 0.8,   // ë°€ì–´ë‚´ëŠ” í˜
                        pullForce: 0.9,   // ëŒì–´ë‹¹ê¸°ëŠ” í˜ (ì•½ê°„ ë” ê°•í•¨)
                        nodeIndex: physicsNodes.indexOf(node)
                    });
                }
            });
            
            console.log(`ğŸª¨ ${magneticStones.length}ê°œì˜ ìì„ ëŒ ìƒì„±ë¨`);
            
            // ì—°ê²°ì„  ë¨¼ì € ê·¸ë¦¬ê¸°
            const centerCoord = physicsNodes.find(c => c.type === 'center');
            physicsNodes.filter(c => c.type === 'person').forEach((coord, index) => {
                const line = document.createElement('div');
                line.className = 'connection-line';
                line.id = `line-${index}`;
                canvas.appendChild(line);
            });
            
            // ë…¸ë“œ ê·¸ë¦¬ê¸°
            physicsNodes.forEach((coord, index) => {
                const node = document.createElement('div');
                node.className = `node ${coord.type === 'center' ? 'center-node' : 'person-node'} color-${coord.color}`;
                node.id = `node-${index}`;
                
                let baseSize, adjustedSize;
                if (coord.type === 'center') {
                    baseSize = 120;
                    adjustedSize = baseSize;
                } else {
                    baseSize = 100;
                    const multiplier = coord.sizeMultiplier || 1.0;
                    adjustedSize = Math.round(baseSize * multiplier);
                }
                
                node.style.width = adjustedSize + 'px';
                node.style.height = adjustedSize + 'px';
                node.style.left = (coord.x - Math.round(adjustedSize / 2)) + 'px';
                node.style.top = (coord.y - Math.round(adjustedSize / 2)) + 'px';
                node.style.position = 'absolute';
                
                if (coord.type === 'center') {
                    node.innerHTML = data.centerConcept;
                } else {
                    node.innerHTML = coord.name;
                    node.dataset.cluster = coord.cluster;
                    
                    const info = document.createElement('div');
                    info.className = 'node-info';
                    info.style.whiteSpace = 'pre-line';
                    info.innerHTML = `
                        <strong>${coord.name}</strong><br><br>
                        ${coord.cColumnData || 'ë°ì´í„° ì—†ìŒ'}
                    `;
                    info.style.left = '110px';
                    info.style.top = '-20px';
                    node.appendChild(info);
                }
                
                canvas.appendChild(node);
                coord.domElement = node;
                coord.size = adjustedSize;
            });
            
            // ì´ˆê¸° ì—°ê²°ì„  ì—…ë°ì´íŠ¸
            updateConnections();
            
            visibleClusters.clear();
            data.clusters.forEach(cluster => visibleClusters.add(cluster.name));
        }
        
        function setupClusterControls(data) {
            const buttonsContainer = document.getElementById('clusterButtons');
            buttonsContainer.innerHTML = '';
            
            data.clusters.forEach(cluster => {
                const button = document.createElement('button');
                button.className = 'cluster-toggle active';
                button.innerHTML = `${getClusterEmoji(cluster.color)} ${cluster.name} (${cluster.members.length})`;
                button.onclick = () => toggleCluster(cluster.name, button);
                buttonsContainer.appendChild(button);
            });
            
            const showAllBtn = document.createElement('button');
            showAllBtn.className = 'cluster-toggle';
            showAllBtn.innerHTML = 'ğŸ‘ï¸ ì „ì²´ ë³´ê¸°';
            showAllBtn.onclick = showAllClusters;
            buttonsContainer.appendChild(showAllBtn);
            
            const hideAllBtn = document.createElement('button');
            hideAllBtn.className = 'cluster-toggle';
            hideAllBtn.innerHTML = 'ğŸ™ˆ ì „ì²´ ìˆ¨ê¸°ê¸°';
            hideAllBtn.onclick = hideAllClusters;
            buttonsContainer.appendChild(hideAllBtn);
        }
        
        function toggleCluster(clusterName, button) {
            const nodes = document.querySelectorAll(`[data-cluster="${clusterName}"]`);
            
            if (visibleClusters.has(clusterName)) {
                nodes.forEach(node => {
                    node.style.opacity = '0.2';
                    node.style.transform = 'scale(0.8)';
                });
                button.classList.remove('active');
                visibleClusters.delete(clusterName);
            } else {
                nodes.forEach(node => {
                    node.style.opacity = '1';
                    node.style.transform = 'scale(1)';
                });
                button.classList.add('active');
                visibleClusters.add(clusterName);
            }
        }
        
        function showAllClusters() {
            document.querySelectorAll('[data-cluster]').forEach(node => {
                node.style.opacity = '1';
                node.style.transform = 'scale(1)';
            });
            document.querySelectorAll('.cluster-toggle').forEach(btn => {
                if (!btn.innerHTML.includes('ğŸ‘ï¸') && !btn.innerHTML.includes('ğŸ™ˆ')) {
                    btn.classList.add('active');
                }
            });
            if (currentData) {
                visibleClusters.clear();
                currentData.clusters.forEach(cluster => visibleClusters.add(cluster.name));
            }
        }
        
        function hideAllClusters() {
            document.querySelectorAll('[data-cluster]').forEach(node => {
                node.style.opacity = '0.2';
                node.style.transform = 'scale(0.8)';
            });
            document.querySelectorAll('.cluster-toggle').forEach(btn => {
                if (!btn.innerHTML.includes('ğŸ‘ï¸') && !btn.innerHTML.includes('ğŸ™ˆ')) {
                    btn.classList.remove('active');
                }
            });
            visibleClusters.clear();
        }
        
        function updateStats(data) {
            document.getElementById('responseCount').textContent = data.stats.totalResponses;
            document.getElementById('keywordCount').textContent = data.stats.totalKeywords;
            document.getElementById('clusterCount').textContent = data.stats.clusterCount;
            document.getElementById('centerConcept').textContent = data.centerConcept;
        }
        
        function getClusterEmoji(color) {
            const emojis = {
                red: 'ğŸ”´', yellow: 'ğŸŸ¡', blue: 'ğŸ”µ', green: 'ğŸŸ¢',
                purple: 'ğŸŸ£', orange: 'ğŸŸ ', pink: 'ğŸ©·', cyan: 'ğŸ”µ'
            };
            return emojis[color] || 'âšª';
        }
        
        function loadSampleData() {
            const sampleData = `íƒ€ì„ìŠ¤íƒ¬í”„,ì´ë¦„,í‚¤ì›Œë“œ,ìš”ì•½,í•´ì„,ì—°ê´€ê°œë…,ë³€í™”ì •ë„,ê·¸ë£¹ì˜ˆìƒ
2024-01-24 10:00:00,ê¹€ë¯¼ì¤€,"í™˜ê²½, ì„¤ê³„, ì‹ í˜¸",í™˜ê²½ì´ í–‰ë™ì„ ë§Œë“ ë‹¤,ë¬¼ë¦¬ì  ê³µê°„ì„ ë°”ê¾¸ë‹ˆ ìŠµê´€ì´ ë‹¬ë¼ì¡Œë‹¤,ë””ìì¸ì”½í‚¹,í¬ê²Œ í™•ì¥,
2024-01-24 11:00:00,ì´ì„œì—°,"ì •ì²´ì„±, ì„±ì¥, ë³€í™”",ì •ì²´ì„± ê¸°ë°˜ ìŠµê´€ì´ ì§€ì†ëœë‹¤,ë‚´ê°€ ëˆ„êµ¬ì¸ì§€ ì •ì˜í•˜ëŠ” ê²ƒë¶€í„° ì‹œì‘,ìê¸°ê³„ë°œ,ìƒˆë¡œìš´ ê´€ì ,
2024-01-24 12:00:00,ë°•ì§€í˜¸,"ì‹œìŠ¤í…œ, ê³¼ì •, ê°œì„ ",ëª©í‘œë³´ë‹¤ ì‹œìŠ¤í…œì— ì§‘ì¤‘í•˜ë¼,ê²°ê³¼ê°€ ì•„ë‹Œ ê³¼ì •ì„ ì„¤ê³„í•´ì•¼,ë°©ë²•ë¡ ,ë¶€ë¶„ì  ìˆ˜ì •,
2024-01-24 13:00:00,ìµœìœ ì§„,"ì‘ì€ë³€í™”, ë³µë¦¬, ëˆ„ì ",1%ì˜ ê°œì„ ì´ 37ë°° ì„±ì¥ì„ ë§Œë“ ë‹¤,ì™„ë²½í•˜ì§€ ì•Šì•„ë„ ê¾¸ì¤€íˆ í•˜ëŠ” ê²Œ ì¤‘ìš”,ìˆ˜í•™,í™•ì¥,
2024-01-24 14:00:00,ì •ë„í˜„,"í”¼ë“œë°±, ì¸¡ì •, ì¶”ì ",ì¸¡ì •ë˜ì§€ ì•Šìœ¼ë©´ ê°œì„ ë˜ì§€ ì•ŠëŠ”ë‹¤,ë°ì´í„°ë¡œ í˜„ìƒì„ íŒŒì•…í•´ì•¼ ë³€í™” ê°€ëŠ¥,ë¶„ì„,ìƒˆë¡œìš´ ê´€ì ,`;
            
            const result = analyzeCSVDataSafely(sampleData);
            if (result) {
                renderTopologyVisualization(result);
                updateStats(result);
                setupClusterControls(result);
                currentData = result;
                
                document.getElementById('clusterControls').style.display = 'block';
                showAlert('info', 'ìƒ˜í”Œ ë°ì´í„°ê°€ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        }
        
        function clearAll() {
            stopPhysicsSimulation();
            document.getElementById('topologyCanvas').innerHTML = `
                <div class="loading">
                    <h3>ğŸ“¡ ë¶ìŠ¤í„°ë”” ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</h3>
                    <p>ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”</p>
                </div>
            `;
            document.getElementById('clusterControls').style.display = 'none';
            updateStats({ stats: { totalResponses: 0, totalKeywords: 0, clusterCount: 0 }, centerConcept: '-' });
            currentData = null;
            physicsNodes = [];
        }
        
        function exportImage() {
            if (!currentData) {
                alert('ë¨¼ì € ë°ì´í„°ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”.');
                return;
            }
            alert('ìŠ¤í¬ë¦°ìƒ·ì„ ì°ì–´ì„œ ì €ì¥í•˜ì„¸ìš”.\nWindows: Win + Shift + S\nMac: Cmd + Shift + 4');
        }
        
        function showAlert(type, message) {
            const existingAlert = document.querySelector('.alert');
            if (existingAlert && existingAlert.textContent !== existingAlert.querySelector('strong').textContent) {
                existingAlert.remove();
            }
            
            const alert = document.createElement('div');
            alert.className = `alert alert-${type === 'success' ? 'success' : 'info'}`;
            alert.innerHTML = message;
            
            document.querySelector('.control-panel').appendChild(alert);
            
            setTimeout(() => {
                if (alert.parentNode) {
                    alert.remove();
                }
            }, 5000);
        }
        
        // ğŸš€ ë¬¼ë¦¬ ì—”ì§„ í•¨ìˆ˜ë“¤
        function startPhysicsSimulation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            isPhysicsEnabled = true;
            console.log('ğŸŒŸ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘!');
            
            setTimeout(() => {
                physicsNodes.forEach(node => {
                    if (!node.isCenter) {
                        // ğŸŸ ì¤‘ì•™ì—ì„œ ë” í™œë°œí•˜ê²Œ ì‹œì‘
                        node.x = 700 + (Math.random() - 0.5) * 150;
                        node.y = 600 + (Math.random() - 0.5) * 150;
                        // ë” í™œë°œí•œ ì´ˆê¸° ì†ë„
                        node.vx = (Math.random() - 0.5) * 20;
                        node.vy = (Math.random() - 0.5) * 20;
                    }
                });
                physicsLoop();
            }, 500);
        }
        
        function physicsLoop() {
            if (!isPhysicsEnabled) return;
            
            updatePhysics();
            updateDOM();
            updateConnections();
            
            animationId = requestAnimationFrame(physicsLoop);
        }
        
        function updatePhysics() {
            const centerNode = physicsNodes.find(n => n.isCenter);
            const damping = 0.98;
            const dt = 0.016;
            const currentTime = performance.now();
            
            physicsNodes.forEach((node, i) => {
                if (node.isCenter) {
                    // ğŸ© ì¤‘ì‹¬ ë…¸ë“œëŠ” ë„ë„› ìì„ ì•ˆì—ì„œë§Œ ì›€ì§ì„
                    const donutRadius = 80;
                    const distFromCenter = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
                    
                    if (distFromCenter > 0.1) {
                        const restoreForce = 0.3;
                        node.vx += -node.vx * restoreForce * dt;
                        node.vy += -node.vy * restoreForce * dt;
                    }
                    
                    node.x += node.vx * dt;
                    node.y += node.vy * dt;
                    
                    const offsetX = node.x - 700;
                    const offsetY = node.y - 600;
                    const dist = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
                    
                    if (dist > donutRadius) {
                        const angle = Math.atan2(offsetY, offsetX);
                        node.x = 700 + Math.cos(angle) * donutRadius;
                        node.y = 600 + Math.sin(angle) * donutRadius;
                        node.vx *= -0.5;
                        node.vy *= -0.5;
                    }
                    
                } else {
                    // ğŸŸ ë¬¼ê³ ê¸°ë“¤ì˜ BRIO ë¯¸ë¡œ ë¬¼ë¦¬í•™!
                    
                    // ğŸ§± 1. BRIO ê°€ìƒë²½ ì¶©ëŒ ì²´í¬ (ëœë¤ ë°œìƒ)
                    if (currentTime - node.lastWallCheck > 500) { // 0.5ì´ˆë§ˆë‹¤ ì²´í¬
                        node.lastWallCheck = currentTime;
                        
                        // ëœë¤í•˜ê²Œ ë²½ê³¼ ì¶©ëŒ (30% í™•ë¥ )
                        if (Math.random() < 0.3) {
                            const randomWall = virtualWalls[Math.floor(Math.random() * virtualWalls.length)];
                            
                            // ë²½ê³¼ì˜ ê±°ë¦¬ ì²´í¬
                            const distToWall = pointToLineDistance(node.x, node.y, randomWall.x1, randomWall.y1, randomWall.x2, randomWall.y2);
                            
                            if (distToWall < randomWall.thickness) {
                                // ìƒˆë¡œìš´ ì¶©ëŒ ì‹œì‘
                                if (!node.wallCollisions.has(randomWall)) {
                                    node.wallCollisions.set(randomWall, {
                                        startTime: currentTime,
                                        resistance: 1.0
                                    });
                                    console.log(`ğŸŸ ë¬¼ê³ ê¸° ${i}ê°€ ë²½ì— ì¶©ëŒ! ğŸ˜¤`);
                                }
                            }
                        }
                    }
                    
                    // ğŸ§± 2. í™œì„± ë²½ ì¶©ëŒ ì €í•­ ê³„ì‚°
                    let totalWallResistance = { x: 0, y: 0 };
                    
                    node.wallCollisions.forEach((collision, wall) => {
                        const elapsedTime = (currentTime - collision.startTime) / 1000; // ì´ˆ ë‹¨ìœ„
                        
                        // BRIO ì €í•­ë„ ê³„ì‚°: 100% â†’ 70% â†’ 30% â†’ 0%
                        let resistance = 0;
                        if (elapsedTime < 1) {
                            resistance = 1.0; // 100% ì €í•­ (1ì´ˆê°„)
                        } else if (elapsedTime < 2) {
                            resistance = 0.7; // 70% ì €í•­ (1-2ì´ˆ)
                        } else if (elapsedTime < 3) {
                            resistance = 0.3; // 30% ì €í•­ (2-3ì´ˆ)
                        } else {
                            resistance = 0; // 0% ì €í•­ (3ì´ˆ í›„)
                            node.wallCollisions.delete(wall); // ì¶©ëŒ ì¢…ë£Œ
                        }
                        
                        if (resistance > 0) {
                            // ë²½ì˜ ë²•ì„  ë²¡í„° ê³„ì‚°
                            const wallVx = wall.x2 - wall.x1;
                            const wallVy = wall.y2 - wall.y1;
                            const wallLength = Math.sqrt(wallVx * wallVx + wallVy * wallVy);
                            
                            if (wallLength > 0) {
                                // ë²½ì— ìˆ˜ì§ì¸ ë°©í–¥ìœ¼ë¡œ ì €í•­
                                const normalX = -wallVy / wallLength;
                                const normalY = wallVx / wallLength;
                                
                                // ë¬¼ê³ ê¸° ì†ë„ì™€ ë²•ì„ ì˜ ë‚´ì  (ë²½ìœ¼ë¡œ í–¥í•˜ëŠ” ì†ë„)
                                const velocityDotNormal = node.vx * normalX + node.vy * normalY;
                                
                                if (velocityDotNormal < 0) { // ë²½ ìª½ìœ¼ë¡œ ì´ë™í•˜ëŠ” ê²½ìš°ë§Œ
                                    totalWallResistance.x += normalX * Math.abs(velocityDotNormal) * resistance * 50;
                                    totalWallResistance.y += normalY * Math.abs(velocityDotNormal) * resistance * 50;
                                }
                            }
                        }
                    });
                    
                    // ğŸª¨ 3. ìì„ ëŒì˜ ë„ë„› ìë ¥ íš¨ê³¼
                    const stone = magneticStones.find(s => s.nodeIndex === i);
                    if (stone) {
                        const dx_stone = node.x - stone.targetX;
                        const dy_stone = node.y - stone.targetY;
                        const dist_stone = Math.sqrt(dx_stone * dx_stone + dy_stone * dy_stone);
                        
                        if (dist_stone > 0) {
                            if (dist_stone > stone.coreRadius && dist_stone < stone.donutRadius) {
                                const pushStrength = stone.pushForce * (1 - (dist_stone - stone.coreRadius) / (stone.donutRadius - stone.coreRadius));
                                node.vx += (dx_stone / dist_stone) * pushStrength * dt * 60;
                                node.vy += (dy_stone / dist_stone) * pushStrength * dt * 60;
                            }
                            else if (dist_stone <= stone.coreRadius) {
                                const pullStrength = stone.pullForce;
                                node.vx -= (dx_stone / dist_stone) * pullStrength * dt * 50;
                                node.vy -= (dy_stone / dist_stone) * pullStrength * dt * 50;
                            }
                            else if (dist_stone > stone.donutRadius) {
                                const guideForce = 0.03;
                                node.vx -= (dx_stone / dist_stone) * guideForce * dt * 30;
                                node.vy -= (dy_stone / dist_stone) * guideForce * dt * 30;
                            }
                        }
                    }
                    
                    // 4. ì¤‘ì‹¬ì— ëŒ€í•œ ì•½í•œ ìŠ¤í”„ë§ í˜
                    const dx = centerNode.x - node.x;
                    const dy = centerNode.y - node.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const targetDist = node.targetRadius || 300;
                    
                    if (dist > 0) {
                        const springForce = 0.005;
                        const force = (dist - targetDist) * springForce;
                        node.vx += (dx / dist) * force * dt;
                        node.vy += (dy / dist) * force * dt;
                    }
                    
                    // 5. ë‹¤ë¥¸ ë¬¼ê³ ê¸°ë“¤ê³¼ì˜ ê°€ë²¼ìš´ ì¶©ëŒ ë°©ì§€
                    physicsNodes.forEach((other, j) => {
                        if (i !== j && !other.isCenter) {
                            const dx2 = other.x - node.x;
                            const dy2 = other.y - node.y;
                            const dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                            const minDist = (node.size + other.size) * 0.6;
                            
                            if (dist2 < minDist && dist2 > 0) {
                                const pushForce = 0.2;
                                const force = (minDist - dist2) * pushForce;
                                node.vx -= (dx2 / dist2) * force * dt * 10;
                                node.vy -= (dy2 / dist2) * force * dt * 10;
                            }
                        }
                    });
                    
                    // 6. ê²½ê³„ ë°˜ë°œ
                    const margin = 50;
                    if (node.x < margin) node.vx += (margin - node.x) * 0.005;
                    if (node.x > 1350) node.vx += (1350 - node.x) * 0.005;
                    if (node.y < margin) node.vy += (margin - node.y) * 0.005;
                    if (node.y > 1150) node.vy += (1150 - node.y) * 0.005;
                    
                    // 7. ğŸŒŠ ì‘ì€ ëœë¤ ë…¸ì´ì¦ˆ (í†¡í†¡ê±°ë¦¼ íš¨ê³¼)
                    const noiseStrength = 0.1;
                    node.vx += (Math.random() - 0.5) * noiseStrength;
                    node.vy += (Math.random() - 0.5) * noiseStrength;
                    
                    // ğŸ§± 8. ë²½ ì €í•­ ì ìš©
                    node.vx += totalWallResistance.x * dt;
                    node.vy += totalWallResistance.y * dt;
                    
                    // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    node.x += node.vx * dt * 60;
                    node.y += node.vy * dt * 60;
                    
                    // ë§ˆì°° ì ìš©
                    node.vx *= damping;
                    node.vy *= damping;
                }
            });
        }
        
        // ğŸ§® ì ê³¼ ì§ì„  ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return Math.sqrt(A * A + B * B);
            
            let param = dot / lenSq;
            
            if (param < 0) {
                return Math.sqrt(A * A + B * B);
            } else if (param > 1) {
                const E = px - x2;
                const F = py - y2;
                return Math.sqrt(E * E + F * F);
            } else {
                const xx = x1 + param * C;
                const yy = y1 + param * D;
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
        }
        
        function updateDOM() {
            physicsNodes.forEach(node => {
                if (node.domElement) {
                    const halfSize = node.size / 2;
                    node.domElement.style.left = (node.x - halfSize) + 'px';
                    node.domElement.style.top = (node.y - halfSize) + 'px';
                }
            });
        }
        
        function updateConnections() {
            const centerNode = physicsNodes.find(n => n.isCenter);
            
            physicsNodes.forEach((node, index) => {
                if (!node.isCenter) {
                    const lineElement = document.getElementById(`line-${index}`);
                    if (lineElement && centerNode) {
                        const dx = node.x - centerNode.x;
                        const dy = node.y - centerNode.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                        
                        lineElement.style.left = centerNode.x + 'px';
                        lineElement.style.top = centerNode.y + 'px';
                        lineElement.style.width = length + 'px';
                        lineElement.style.transform = `rotate(${angle}deg)`;
                        lineElement.style.zIndex = '1';
                    }
                }
            });
        }
        
        function stopPhysicsSimulation() {
            isPhysicsEnabled = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            console.log('ğŸ›‘ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì •ì§€');
        }
        
        function togglePhysics() {
            const button = document.getElementById('physicsToggle');
            
            if (isPhysicsEnabled) {
                stopPhysicsSimulation();
                button.textContent = 'ğŸŸ ë¬¼ë¦¬ OFF';
                button.style.background = '#6c757d';
                showAlert('info', 'ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ì´ ì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } else {
                if (physicsNodes.length > 0) {
                    startPhysicsSimulation();
                    button.textContent = 'ğŸŸ ë¬¼ë¦¬ ON';
                    button.style.background = '#28a745';
                    showAlert('success', 'ğŸŒŸ ë¬¼ê³ ê¸° ë–¼ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘! ë…¸ë“œë“¤ì´ ìœ ê¸°ì ìœ¼ë¡œ ì›€ì§ì…ë‹ˆë‹¤.');
                } else {
                    showAlert('error', 'ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•´ì£¼ì„¸ìš”.');
                }
            }
        }
    </script>
</body>
</html>
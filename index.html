<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자동 토폴로지 마인드맵</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .title {
            font-size: 28px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #666;
            font-size: 16px;
        }
        
        .control-panel {
            background: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .csv-input {
            width: 100%;
            height: 150px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-family: monospace;
            font-size: 13px;
            resize: vertical;
            margin-bottom: 15px;
        }
        
        .button {
            background: #007acc;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 5px;
            transition: all 0.3s;
        }
        
        .button:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }
        
        .button-success {
            background: #28a745;
        }
        
        .button-success:hover {
            background: #1e7e34;
        }
        
        .button-danger {
            background: #dc3545;
        }
        
        .topology-canvas {
            background: #f8fdf8;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            position: relative;
            height: 1200px;
            overflow: hidden;
        }
        
        .node {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            user-select: none;
        }
        
        .node:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }
        
        .center-node {
            width: 120px;
            height: 120px;
            background: #000;
            color: white;
            font-size: 16px;
            z-index: 5;
            border: 4px solid #333;
        }
        
        .person-node {
            width: 100px;
            height: 100px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            border: 3px solid rgba(255,255,255,0.3);
            line-height: 1.1;
            word-break: keep-all;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 5px;
            position: relative;
        }
        
        .node-info {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 30;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            max-width: 600px;
            min-width: 300px;
            white-space: pre-line;
            word-wrap: break-word;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .node:hover .node-info {
            opacity: 1 !important;
            transform: translateY(-50%) scale(1) !important;
        }
        
        .connection-line {
            position: absolute;
            height: 2px;
            background: rgba(0,0,0,0.2);
            transform-origin: left center;
            z-index: 1;
            transition: all 0.3s;
        }
        
        .connection-line:hover {
            background: rgba(0,0,0,0.4);
            height: 3px;
        }
        
        .cluster-controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .cluster-toggle {
            display: inline-block;
            padding: 8px 16px;
            margin: 5px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s;
        }
        
        .cluster-toggle.active {
            background: #007acc;
            transform: scale(1.05);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .stat-number {
            font-size: 32px;
            font-weight: bold;
            color: #007acc;
        }
        
        .stat-label {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .alert {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid;
        }
        
        .alert-info {
            background: #d1ecf1;
            border-color: #17a2b8;
            color: #0c5460;
        }
        
        .alert-success {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
        }
        
        .color-red { 
            background: linear-gradient(135deg, #ffb3b3 0%, #ff8080 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-yellow { 
            background: linear-gradient(135deg, #fff2b3 0%, #ffe680 100%);
            color: #555; 
            text-shadow: none;
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-blue { 
            background: linear-gradient(135deg, #b3d9ff 0%, #80c4ff 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-green { 
            background: linear-gradient(135deg, #b3f0b3 0%, #80e680 100%);
            color: #333; 
            text-shadow: none;
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-purple { 
            background: linear-gradient(135deg, #e6b3ff 0%, #d580ff 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-orange { 
            background: linear-gradient(135deg, #ffd9b3 0%, #ffbf80 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-pink { 
            background: linear-gradient(135deg, #ffb3e6 0%, #ff80d5 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        .color-cyan { 
            background: linear-gradient(135deg, #b3f0ff 0%, #80e6ff 100%);
            border: 2px solid rgba(255, 255, 255, 0.6);
        }
        
        .loading {
            text-align: center;
            color: #007acc;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">🧠 자동 토폴로지 마인드맵</div>
            <div class="subtitle">북스터디 데이터가 자동으로 시각화됩니다</div>
        </div>
        
        <div class="stats" id="statsContainer">
            <div class="stat-card">
                <div class="stat-number" id="responseCount">0</div>
                <div class="stat-label">총 응답</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="keywordCount">0</div>
                <div class="stat-label">키워드</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="clusterCount">0</div>
                <div class="stat-label">클러스터</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="centerConcept">-</div>
                <div class="stat-label">중심 개념</div>
            </div>
        </div>
        
        <div class="control-panel">
            <h3>📊 데이터 상태</h3>
            <div class="alert alert-info">
                <strong>자동 업데이트:</strong> 구글 스프레드시트에서 5분마다 자동 동기화됩니다
            </div>
            
            <div>
                <button class="button button-success" onclick="loadAutoData()">🔄 최신 데이터 로드</button>
                <button class="button" onclick="loadSampleData()">📝 샘플 데이터 보기</button>
                <button class="button button-danger" onclick="clearAll()">🗑️ 화면 지우기</button>
                <button class="button" onclick="exportImage()">📸 이미지 저장</button>
            </div>
        </div>
        
        <div class="cluster-controls" id="clusterControls" style="display: none;">
            <h3>🎛️ 클러스터 토글</h3>
            <div id="clusterButtons"></div>
        </div>
        
        <div class="topology-canvas" id="topologyCanvas">
            <div class="loading">
                <h3>📡 북스터디 데이터를 불러오는 중...</h3>
                <p>잠시만 기다려주세요</p>
            </div>
        </div>
    </div>

    <script>
        let currentData = null;
        let visibleClusters = new Set();
        
        // 페이지 로드 시 자동으로 데이터 로드
        window.addEventListener('DOMContentLoaded', function() {
            loadAutoData();
        });
        
        async function loadAutoData() {
            try {
                showAlert('info', '최신 데이터를 불러오는 중...');
                
                // GitHub에서 book_study_data.txt 파일 읽기 (캐시 방지)
                const cacheBuster = new Date().getTime();
                const response = await fetch(`./book_study_data.txt?v=${cacheBuster}`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvData = await response.text();
                
                if (!csvData.trim()) {
                    throw new Error('데이터 파일이 비어있습니다.');
                }
                
                // TSV를 CSV로 변환 (탭을 쉼표로)
                const csvConverted = csvData.replace(/\t/g, ',');
                
                // 데이터 분석 및 시각화 (오류 방지 강화)
                const result = analyzeCSVDataSafely(csvConverted);
                
                if (!result || !result.clusters || result.clusters.length === 0) {
                    throw new Error('유효한 클러스터 데이터가 생성되지 않았습니다.');
                }
                
                renderTopologyVisualization(result);
                updateStats(result);
                setupClusterControls(result);
                currentData = result;
                
                document.getElementById('clusterControls').style.display = 'block';
                
                showAlert('success', `자동 로드 완료! ${result.responses.length}개 응답, ${result.clusters.length}개 클러스터가 생성되었습니다.`);
                
            } catch (error) {
                console.error('데이터 로드 오류:', error);
                showAlert('error', `데이터 로드 실패: ${error.message}. 샘플 데이터를 표시합니다.`);
                loadSampleData();
            }
        }
        
        // 안전한 데이터 분석 함수 (오류 방지 강화)
        function analyzeCSVDataSafely(csvData) {
            try {
                const lines = csvData.trim().split('\n');
                const responses = [];
                
                // 최소 2줄 이상 있어야 함 (헤더 + 데이터)
                if (lines.length < 2) {
                    console.warn('데이터가 너무 적습니다. 샘플 데이터를 사용합니다.');
                    return null;
                }
                
                // CSV 파싱 - 오류 방지 강화
                for (let i = 1; i < lines.length; i++) {
                    try {
                        const values = parseCSVLine(lines[i]);
                        
                        // 최소 조건 확인 (B열 이름, C열 내용 중 하나라도 있으면 유효)
                        if (values.length >= 2) {
                            const name = values[1] ? values[1].replace(/"/g, '').trim() : '';
                            const cColumnRaw = values[2] ? values[2].replace(/"/g, '').trim() : '';
                            
                            // 유효한 데이터만 추가
                            if (name || cColumnRaw) {
                                const response = {
                                    name: name || `응답자${i}`,
                                    keywords: cColumnRaw ? cColumnRaw.split(/[,\s]+/).filter(k => k.trim()) : ['기타'],
                                    summary: values[3] ? values[3].replace(/"/g, '').trim() : '',
                                    interpretation: values[4] ? values[4].replace(/"/g, '').trim() : '',
                                    cColumnData: cColumnRaw || '내용 없음'
                                };
                                responses.push(response);
                            }
                        }
                    } catch (rowError) {
                        console.warn(`행 ${i} 파싱 오류:`, rowError);
                        continue; // 해당 행만 건너뛰고 계속 진행
                    }
                }
                
                console.log(`파싱 완료: ${responses.length}개 응답 처리됨`);
                
                if (responses.length === 0) {
                    console.warn('유효한 응답이 없습니다.');
                    return null;
                }
                
                // 클러스터링 (오류 방지)
                const clusters = performAutomaticClusteringSafely(responses);
                
                if (!clusters || clusters.length === 0) {
                    console.warn('클러스터 생성 실패');
                    return null;
                }
                
                // 좌표 계산
                const coordinates = calculateAutoCoordinates(clusters);
                
                // 중심 개념 결정
                const allKeywords = responses.flatMap(r => r.keywords || []);
                const keywordFreq = {};
                allKeywords.forEach(k => {
                    if (k && k.trim()) {
                        keywordFreq[k] = (keywordFreq[k] || 0) + 1;
                    }
                });
                
                const centerConcept = Object.keys(keywordFreq).length > 0 ? 
                    Object.entries(keywordFreq).sort((a, b) => b[1] - a[1])[0]?.[0] : '디지털웰빙';
                
                return {
                    responses,
                    clusters,
                    coordinates,
                    centerConcept: '디지털웰빙',
                    stats: {
                        totalResponses: responses.length,
                        totalKeywords: Object.keys(keywordFreq).length,
                        clusterCount: clusters.length
                    }
                };
                
            } catch (error) {
                console.error('데이터 분석 중 오류:', error);
                return null;
            }
        }
        
        // 이전 순위 데이터를 저장할 전역 변수
        let previousRankings = {};
        
        // 순위 변동 감지 및 크기 조절을 위한 함수
        function detectRankChanges(clusters) {
            const currentRankings = {};
            
            clusters.forEach(cluster => {
                // 현재 클러스터의 빈도수 기반 순위 계산
                const contentFreq = {};
                
                if (cluster.members && Array.isArray(cluster.members)) {
                    cluster.members.forEach(member => {
                        const content = member.cColumnData?.trim();
                        if (content && content.length > 0 && content !== '내용 없음') {
                            contentFreq[content] = (contentFreq[content] || 0) + 1;
                        }
                    });
                }
                
                // 빈도수 기준 정렬하여 현재 순위 생성
                const sortedContents = Object.entries(contentFreq)
                    .sort((a, b) => b[1] - a[1]);
                
                // 각 내용별 현재 순위 저장
                sortedContents.forEach(([content, frequency], index) => {
                    const key = `${cluster.name}:${content}`;
                    currentRankings[key] = {
                        rank: index + 1,
                        frequency: frequency,
                        cluster: cluster.name
                    };
                });
            });
            
            // 순위 변동 계산
            const rankChanges = {};
            
            Object.keys(currentRankings).forEach(key => {
                const current = currentRankings[key];
                const previous = previousRankings[key];
                
                if (previous) {
                    // 이전 데이터가 있는 경우 순위 변동 계산
                    if (current.rank > previous.rank) {
                        // 순위가 떨어짐 (숫자가 커짐 = 순위 하락)
                        rankChanges[key] = {
                            type: 'down',
                            previousRank: previous.rank,
                            currentRank: current.rank,
                            sizeMultiplier: 0.8 // -20% 크기
                        };
                    } else if (current.rank < previous.rank) {
                        // 순위가 올라감
                        rankChanges[key] = {
                            type: 'up',
                            previousRank: previous.rank,
                            currentRank: current.rank,
                            sizeMultiplier: 1.0 // 원래 크기 유지
                        };
                    } else {
                        // 순위 동일
                        rankChanges[key] = {
                            type: 'same',
                            previousRank: previous.rank,
                            currentRank: current.rank,
                            sizeMultiplier: 1.0 // 원래 크기 유지
                        };
                    }
                } else {
                    // 새로 등장한 내용
                    rankChanges[key] = {
                        type: 'new',
                        previousRank: null,
                        currentRank: current.rank,
                        sizeMultiplier: 1.0 // 원래 크기
                    };
                }
            });
            
            // 이전 순위 업데이트
            previousRankings = { ...currentRankings };
            
            console.log('순위 변동 감지:', rankChanges);
            return rankChanges;
        }
        function performAutomaticClusteringSafely(responses) {
            try {
                const clusterSeeds = [
                    { name: "환경설계", keywords: ["물리적환경", "공간배치", "트리거설정", "환경디자인"], color: "red" },
                    { name: "개인성장", keywords: ["정체성", "자아개발", "마음가짐", "내적변화", "성장마인드"], color: "yellow" },
                    { name: "시스템사고", keywords: ["시스템", "프로세스", "체계적", "구조화", "방법론"], color: "blue" },
                    { name: "지속성", keywords: ["반복", "루틴", "꾸준함", "지속가능", "일관성", "습관화"], color: "green" },
                    { name: "사회적관계", keywords: ["관계", "공동체", "사회적책임", "동료", "협력", "네트워크"], color: "purple" },
                    { name: "점진적변화", keywords: ["작은변화", "복리효과", "누적", "단계적", "점진적개선"], color: "orange" },
                    { name: "감정동기", keywords: ["감정", "동기부여", "만족감", "성취감", "자신감"], color: "pink" },
                    { name: "실용적도구", keywords: ["도구", "기술활용", "앱", "디지털도구", "실행방법"], color: "cyan" }
                ];
                
                const clusters = [];
                let totalAssigned = 0;
                
                // 모든 응답을 순회하며 클러스터에 배정
                responses.forEach((response, index) => {
                    try {
                        let bestMatch = { score: 0, cluster: null };
                        
                        // 키워드 매칭 (안전하게)
                        clusterSeeds.forEach(seed => {
                            try {
                                const keywords = response.keywords || [];
                                const matchScore = keywords.filter(keyword => {
                                    if (!keyword || typeof keyword !== 'string') return false;
                                    return seed.keywords.some(seedKeyword => {
                                        if (!seedKeyword || typeof seedKeyword !== 'string') return false;
                                        const kw = keyword.toLowerCase().trim();
                                        const sw = seedKeyword.toLowerCase().trim();
                                        return kw === sw || 
                                               (kw.length > 2 && sw.includes(kw)) ||
                                               (sw.length > 2 && kw.includes(sw));
                                    });
                                }).length;
                                
                                if (matchScore > bestMatch.score) {
                                    bestMatch = { score: matchScore, cluster: seed };
                                }
                            } catch (matchError) {
                                console.warn('매칭 오류:', matchError);
                            }
                        });
                        
                        // 매칭되지 않으면 순환 배정
                        if (bestMatch.score === 0) {
                            const fallbackIndex = index % clusterSeeds.length;
                            bestMatch.cluster = clusterSeeds[fallbackIndex];
                        }
                        
                        // 클러스터에 추가
                        let cluster = clusters.find(c => c.name === bestMatch.cluster.name);
                        if (!cluster) {
                            cluster = {
                                name: bestMatch.cluster.name,
                                color: bestMatch.cluster.color,
                                members: [],
                                keywords: []
                            };
                            clusters.push(cluster);
                        }
                        
                        cluster.members.push(response);
                        if (response.keywords) {
                            cluster.keywords.push(...response.keywords);
                        }
                        totalAssigned++;
                        
                    } catch (responseError) {
                        console.warn(`응답 ${index} 처리 오류:`, responseError);
                    }
                });
                
                console.log(`클러스터링 완료: ${totalAssigned}개 배정, ${clusters.length}개 클러스터`);
                return clusters;
                
            } catch (error) {
                console.error('클러스터링 오류:', error);
                return [];
            }
        }
        
        function analyzeCSVData(csvData) {
            const lines = csvData.trim().split('\n');
            const responses = [];
            
            // CSV 파싱 - C열(인덱스 2) 전체 데이터 보존
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                if (values.length >= 3 && values[1]) {
                    const response = {
                        name: values[1].replace(/"/g, ''),
                        keywords: values[2] ? values[2].replace(/"/g, '').split(/[,\s]+/).filter(k => k.trim()) : [],
                        summary: values[3] ? values[3].replace(/"/g, '') : '',
                        interpretation: values[4] ? values[4].replace(/"/g, '') : '',
                        cColumnData: values[2] ? values[2].replace(/"/g, '').trim() : ''  // C열 전체 내용 보존
                    };
                    if (response.cColumnData || response.keywords.length > 0) {  // C열 데이터가 있으면 포함
                        responses.push(response);
                    }
                }
            }
            
            if (responses.length === 0) {
                throw new Error('유효한 응답 데이터가 없습니다.');
            }
            
            // 클러스터링
            const clusters = performAutomaticClustering(responses);
            
            // 좌표 계산
            const coordinates = calculateAutoCoordinates(clusters);
            
            // 중심 개념 결정
            const allKeywords = responses.flatMap(r => r.keywords);
            const keywordFreq = {};
            allKeywords.forEach(k => keywordFreq[k] = (keywordFreq[k] || 0) + 1);
            const centerConcept = Object.entries(keywordFreq)
                .sort((a, b) => b[1] - a[1])[0]?.[0] || '북스터디';
            
            return {
                responses,
                clusters,
                coordinates,
                centerConcept: '디지털웰빙',  // 중심 개념을 '디지털웰빙'으로 고정
                stats: {
                    totalResponses: responses.length,
                    totalKeywords: Object.keys(keywordFreq).length,
                    clusterCount: clusters.length
                }
            };
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());  // 공백 제거
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());  // 마지막 항목도 공백 제거
            return result;
        }
        
        function performAutomaticClustering(responses) {
            const clusterSeeds = [
                { name: "환경설계", keywords: ["물리적환경", "공간배치", "트리거설정", "환경디자인"], color: "red" },
                { name: "개인성장", keywords: ["정체성", "자아개발", "마음가짐", "내적변화", "성장마인드"], color: "yellow" },
                { name: "시스템사고", keywords: ["시스템", "프로세스", "체계적", "구조화", "방법론"], color: "blue" },
                { name: "지속성", keywords: ["반복", "루틴", "꾸준함", "지속가능", "일관성", "습관화"], color: "green" },
                { name: "사회적관계", keywords: ["관계", "공동체", "사회적책임", "동료", "협력", "네트워크"], color: "purple" },
                { name: "점진적변화", keywords: ["작은변화", "복리효과", "누적", "단계적", "점진적개선"], color: "orange" },
                { name: "감정동기", keywords: ["감정", "동기부여", "만족감", "성취감", "자신감"], color: "pink" },
                { name: "실용적도구", keywords: ["도구", "기술활용", "앱", "디지털도구", "실행방법"], color: "cyan" }
            ];
            
            const clusters = [];
            let totalAssigned = 0;
            
            // 모든 응답을 순회하며 클러스터에 배정 (중복 제거 없음)
            responses.forEach((response, index) => {
                let bestMatch = { score: 0, cluster: null };
                
                // 더 엄격한 키워드 매칭
                clusterSeeds.forEach(seed => {
                    const matchScore = response.keywords.filter(keyword => 
                        seed.keywords.some(seedKeyword => 
                            keyword.toLowerCase() === seedKeyword.toLowerCase() ||
                            (keyword.length > 3 && seedKeyword.toLowerCase().includes(keyword.toLowerCase())) ||
                            (seedKeyword.length > 3 && keyword.toLowerCase().includes(seedKeyword.toLowerCase()))
                        )
                    ).length;
                    
                    if (matchScore > bestMatch.score) {
                        bestMatch = { score: matchScore, cluster: seed };
                    }
                });
                
                // 매칭되지 않으면 키워드 유사도 기반으로 배정
                if (bestMatch.score === 0) {
                    let fallbackMatch = { score: 0, cluster: clusterSeeds[0] };
                    clusterSeeds.forEach((seed, seedIndex) => {
                        // 인덱스 기반 순환 배정으로 고른 분포
                        const cyclicScore = (index + seedIndex) % clusterSeeds.length;
                        if (cyclicScore > fallbackMatch.score || 
                            (cyclicScore === fallbackMatch.score && Math.random() > 0.5)) {
                            fallbackMatch = { score: cyclicScore, cluster: seed };
                        }
                    });
                    bestMatch.cluster = fallbackMatch.cluster;
                }
                
                let cluster = clusters.find(c => c.name === bestMatch.cluster.name);
                if (!cluster) {
                    cluster = {
                        name: bestMatch.cluster.name,
                        color: bestMatch.cluster.color,
                        members: [],
                        keywords: []
                    };
                    clusters.push(cluster);
                }
                
                cluster.members.push(response);
                cluster.keywords.push(...response.keywords);
                totalAssigned++;
            });
            
            console.log(`총 응답 수: ${responses.length}, 배정된 수: ${totalAssigned}`);
            console.log('클러스터별 분포:', clusters.map(c => `${c.name}: ${c.members.length}`));
            
            return clusters;
        }
        
        function calculateAutoCoordinates(clusters) {
            const centerX = 700, centerY = 600;
            const baseRadius = 280;
            const coordinates = [];
            
            // 순위 변동 감지
            const rankChanges = detectRankChanges(clusters);
            
            // 중심점 - 캔버스 정 가운데 고정
            coordinates.push({
                name: "중심개념",
                x: centerX,
                y: centerY,
                color: "black",
                size: "large",
                type: "center"
            });
            
            // 각 클러스터당 정확히 3개 원형 생성 (빈도수 기반 TOP 3) - 크기 동적 조절
            clusters.forEach((cluster, clusterIndex) => {
                try {
                    const clusterAngle = (360 / clusters.length) * clusterIndex;
                    
                    // 클러스터 내 C열 데이터 빈도수 계산 (안전하게)
                    const contentFreq = {};
                    const contentAuthors = {};
                    
                    if (cluster.members && Array.isArray(cluster.members)) {
                        cluster.members.forEach((member, memberIndex) => {
                            try {
                                const content = member.cColumnData?.trim();
                                const name = member.name?.trim() || `응답자${memberIndex + 1}`;
                                
                                if (content && content.length > 0 && content !== '내용 없음') {
                                    contentFreq[content] = (contentFreq[content] || 0) + 1;
                                    if (!contentAuthors[content]) {
                                        contentAuthors[content] = [];
                                    }
                                    contentAuthors[content].push(name);
                                }
                            } catch (memberError) {
                                console.warn('멤버 처리 오류:', memberError);
                            }
                        });
                    }
                    
                    // 빈도수 기준 정렬하여 TOP 3 추출
                    const topContents = Object.entries(contentFreq)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3);
                    
                    // 클러스터당 3개 원형 생성 (TOP 1, 2, 3) - 순위 변동 반영
                    for (let nodeIndex = 0; nodeIndex < 3; nodeIndex++) {
                        try {
                            const nodeAngle = clusterAngle + (nodeIndex - 1) * 25;
                            const radius = baseRadius + (nodeIndex * 60);
                            
                            const x = centerX + Math.cos(nodeAngle * Math.PI / 180) * radius;
                            const y = centerY + Math.sin(nodeAngle * Math.PI / 180) * radius;
                            
                            let displayText, tooltipContent, sizeMultiplier = 1.0;
                            
                            if (topContents[nodeIndex]) {
                                const [content, frequency] = topContents[nodeIndex];
                                const authors = contentAuthors[content] || [];
                                
                                // 순위 변동에 따른 크기 조절
                                const rankKey = `${cluster.name}:${content}`;
                                if (rankChanges[rankKey]) {
                                    sizeMultiplier = rankChanges[rankKey].sizeMultiplier;
                                    
                                    // 순위 변동 정보를 툴팁에 추가
                                    const rankInfo = rankChanges[rankKey];
                                    let rankChangeText = '';
                                    if (rankInfo.type === 'down') {
                                        rankChangeText = `\n📉 순위 변동: ${rankInfo.previousRank}등 → ${rankInfo.currentRank}등 (하락)`;
                                    } else if (rankInfo.type === 'up') {
                                        rankChangeText = `\n📈 순위 변동: ${rankInfo.previousRank}등 → ${rankInfo.currentRank}등 (상승)`;
                                    } else if (rankInfo.type === 'new') {
                                        rankChangeText = `\n🆕 신규 등장: ${rankInfo.currentRank}등`;
                                    }
                                    
                                    // 첫 3어절만 표시 (안전하게)
                                    const words = content.split(' ').filter(w => w.trim()).slice(0, 3);
                                    displayText = words.length > 0 ? words.join(' ') : 
                                                (content.length > 15 ? content.substring(0, 15) + '...' : content);
                                    
                                    // 작성자 목록 (최대 3명 + ...)
                                    const uniqueAuthors = [...new Set(authors)]; // 중복 제거
                                    const authorsList = uniqueAuthors.slice(0, 3).join(', ') + 
                                                      (uniqueAuthors.length > 3 ? ' ...' : '');
                                    
                                    tooltipContent = `${content}\n\n작성자: ${authorsList}\n빈도: ${frequency}회${rankChangeText}`;
                                } else {
                                    // 순위 변동 정보가 없는 경우 (첫 로드)
                                    const words = content.split(' ').filter(w => w.trim()).slice(0, 3);
                                    displayText = words.length > 0 ? words.join(' ') : 
                                                (content.length > 15 ? content.substring(0, 15) + '...' : content);
                                    
                                    const uniqueAuthors = [...new Set(authors)];
                                    const authorsList = uniqueAuthors.slice(0, 3).join(', ') + 
                                                      (uniqueAuthors.length > 3 ? ' ...' : '');
                                    
                                    tooltipContent = `${content}\n\n작성자: ${authorsList}\n빈도: ${frequency}회\n🔄 초기 데이터`;
                                }
                            } else {
                                // TOP 3에 해당하는 데이터가 없는 경우
                                displayText = `${cluster.name} ${nodeIndex + 1}`;
                                tooltipContent = `${cluster.name} 클러스터\n순위 ${nodeIndex + 1} - 데이터 부족`;
                            }
                            
                            coordinates.push({
                                name: displayText,
                                x: Math.max(50, Math.min(1350, x)),
                                y: Math.max(50, Math.min(1150, y)),
                                color: cluster.color,
                                size: "medium",
                                type: "person",
                                cluster: cluster.name,
                                keywords: (cluster.keywords || []).slice(0, 5).join(", "),
                                summary: "",
                                cColumnData: tooltipContent,
                                nodeType: "frequency-based",
                                rank: nodeIndex + 1,
                                sizeMultiplier: sizeMultiplier // 크기 조절 비율 추가
                            });
                        } catch (nodeError) {
                            console.warn(`노드 ${nodeIndex} 생성 오류:`, nodeError);
                        }
                    }
                } catch (clusterError) {
                    console.warn(`클러스터 ${clusterIndex} 처리 오류:`, clusterError);
                }
            });
            
            return coordinates;
        }
        
        function renderTopologyVisualization(data) {
            const canvas = document.getElementById('topologyCanvas');
            canvas.innerHTML = '';
            
            console.log('렌더링 시작 - 총 노드 수:', data.coordinates.length);
            
            // 연결선 먼저 그리기
            const centerCoord = data.coordinates.find(c => c.type === 'center');
            if (centerCoord) {
                data.coordinates.filter(c => c.type === 'person').forEach(coord => {
                    const line = document.createElement('div');
                    line.className = 'connection-line';
                    
                    const dx = coord.x - centerCoord.x;
                    const dy = coord.y - centerCoord.y;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    line.style.left = centerCoord.x + 'px';
                    line.style.top = centerCoord.y + 'px';
                    line.style.width = length + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.zIndex = '1';
                    
                    canvas.appendChild(line);
                });
            }
            
            // 노드 그리기 - 모든 노드 확실히 렌더링
            data.coordinates.forEach((coord, index) => {
                console.log(`노드 ${index} 렌더링:`, coord.name, coord.type);
                
                const node = document.createElement('div');
                node.className = `node ${coord.type === 'center' ? 'center-node' : 'person-node'} color-${coord.color}`;
                
                // 순위 변동에 따른 동적 크기 조절
                let baseSize, adjustedSize;
                if (coord.type === 'center') {
                    baseSize = 120;
                    adjustedSize = baseSize;
                    node.style.left = (coord.x - 60) + 'px';
                    node.style.top = (coord.y - 60) + 'px';
                } else {
                    baseSize = 100;
                    // sizeMultiplier를 적용 (순위 하락 시 0.8배)
                    const multiplier = coord.sizeMultiplier || 1.0;
                    adjustedSize = Math.round(baseSize * multiplier);
                    
                    node.style.left = (coord.x - 50) + 'px';
                    node.style.top = (coord.y - 50) + 'px';
                    
                    // 크기 변경 애니메이션 추가
                    if (multiplier < 1.0) {
                        node.style.transform = 'scale(1)';
                        node.style.transition = 'all 0.8s ease-in-out';
                        // 약간의 딜레이 후 크기 적용
                        setTimeout(() => {
                            node.style.transform = `scale(${multiplier})`;
                        }, 100);
                    }
                }
                
                node.style.width = adjustedSize + 'px';
                node.style.height = adjustedSize + 'px';
                
                // 순위 변동 표시를 위한 특별한 효과
                if (coord.sizeMultiplier && coord.sizeMultiplier < 1.0) {
                    node.style.opacity = '0.85'; // 약간 투명하게
                    node.style.boxShadow = '0 2px 10px rgba(255, 0, 0, 0.3)'; // 빨간 그림자
                } else if (coord.sizeMultiplier && coord.sizeMultiplier >= 1.0 && coord.rank) {
                    node.style.boxShadow = '0 4px 15px rgba(0, 255, 0, 0.2)'; // 초록 그림자 (순위 상승/유지)
                }
                
                if (coord.type === 'center') {
                    node.innerHTML = data.centerConcept;
                } else {
                    // 원형 내부 텍스트
                    node.textContent = coord.name;
                    node.dataset.cluster = coord.cluster;
                    
                    // 툴팁 정보 - 마우스 이벤트와 함께
                    const info = document.createElement('div');
                    info.className = 'node-info';
                    info.innerHTML = `<strong>${coord.name}</strong><br><br>${coord.cColumnData || '데이터 없음'}`;
                    
                    // 툴팁 위치 설정
                    info.style.left = '120px';
                    info.style.top = '-30px';
                    
                    node.appendChild(info);
                }
                
                canvas.appendChild(node);
                console.log(`노드 ${index} 추가 완료`);
            });
            
            console.log('렌더링 완료 - 캔버스 자식 수:', canvas.children.length);
            
            // 모든 클러스터를 기본적으로 보이게
            visibleClusters.clear();
            data.clusters.forEach(cluster => visibleClusters.add(cluster.name));
        }
        
        function setupClusterControls(data) {
            const buttonsContainer = document.getElementById('clusterButtons');
            buttonsContainer.innerHTML = '';
            
            data.clusters.forEach(cluster => {
                const button = document.createElement('button');
                button.className = 'cluster-toggle active';
                button.innerHTML = `${getClusterEmoji(cluster.color)} ${cluster.name} (${cluster.members.length})`;
                button.onclick = () => toggleCluster(cluster.name, button);
                buttonsContainer.appendChild(button);
            });
            
            // 전체 제어 버튼
            const showAllBtn = document.createElement('button');
            showAllBtn.className = 'cluster-toggle';
            showAllBtn.innerHTML = '👁️ 전체 보기';
            showAllBtn.onclick = showAllClusters;
            buttonsContainer.appendChild(showAllBtn);
            
            const hideAllBtn = document.createElement('button');
            hideAllBtn.className = 'cluster-toggle';
            hideAllBtn.innerHTML = '🙈 전체 숨기기';
            hideAllBtn.onclick = hideAllClusters;
            buttonsContainer.appendChild(hideAllBtn);
        }
        
        function toggleCluster(clusterName, button) {
            const nodes = document.querySelectorAll(`[data-cluster="${clusterName}"]`);
            
            if (visibleClusters.has(clusterName)) {
                nodes.forEach(node => {
                    node.style.opacity = '0.2';
                    node.style.transform = 'scale(0.8)';
                });
                button.classList.remove('active');
                visibleClusters.delete(clusterName);
            } else {
                nodes.forEach(node => {
                    node.style.opacity = '1';
                    node.style.transform = 'scale(1)';
                });
                button.classList.add('active');
                visibleClusters.add(clusterName);
            }
        }
        
        function showAllClusters() {
            document.querySelectorAll('[data-cluster]').forEach(node => {
                node.style.opacity = '1';
                node.style.transform = 'scale(1)';
            });
            document.querySelectorAll('.cluster-toggle').forEach(btn => {
                if (!btn.innerHTML.includes('👁️') && !btn.innerHTML.includes('🙈')) {
                    btn.classList.add('active');
                }
            });
            if (currentData) {
                visibleClusters.clear();
                currentData.clusters.forEach(cluster => visibleClusters.add(cluster.name));
            }
        }
        
        function hideAllClusters() {
            document.querySelectorAll('[data-cluster]').forEach(node => {
                node.style.opacity = '0.2';
                node.style.transform = 'scale(0.8)';
            });
            document.querySelectorAll('.cluster-toggle').forEach(btn => {
                if (!btn.innerHTML.includes('👁️') && !btn.innerHTML.includes('🙈')) {
                    btn.classList.remove('active');
                }
            });
            visibleClusters.clear();
        }
        
        function updateStats(data) {
            document.getElementById('responseCount').textContent = data.stats.totalResponses;
            document.getElementById('keywordCount').textContent = data.stats.totalKeywords;
            document.getElementById('clusterCount').textContent = data.stats.clusterCount;
            document.getElementById('centerConcept').textContent = data.centerConcept;
        }
        
        function getClusterEmoji(color) {
            const emojis = {
                red: '🔴', yellow: '🟡', blue: '🔵', green: '🟢',
                purple: '🟣', orange: '🟠', pink: '🩷', cyan: '🔵'
            };
            return emojis[color] || '⚪';
        }
        
        function loadSampleData() {
            const sampleData = `타임스탬프,이름,키워드,요약,해석,연관개념,변화정도,그룹예상
2024-01-24 10:00:00,김민준,"환경, 설계, 신호",환경이 행동을 만든다,물리적 공간을 바꾸니 습관이 달라졌다,디자인씽킹,크게 확장,
2024-01-24 11:00:00,이서연,"정체성, 성장, 변화",정체성 기반 습관이 지속된다,내가 누구인지 정의하는 것부터 시작,자기계발,새로운 관점,
2024-01-24 12:00:00,박지호,"시스템, 과정, 개선",목표보다 시스템에 집중하라,결과가 아닌 과정을 설계해야,방법론,부분적 수정,
2024-01-24 13:00:00,최유진,"작은변화, 복리, 누적",1%의 개선이 37배 성장을 만든다,완벽하지 않아도 꾸준히 하는 게 중요,수학,확장,
2024-01-24 14:00:00,정도현,"피드백, 측정, 추적",측정되지 않으면 개선되지 않는다,데이터로 현상을 파악해야 변화 가능,분석,새로운 관점,`;
            
            const result = analyzeCSVData(sampleData);
            renderTopologyVisualization(result);
            updateStats(result);
            setupClusterControls(result);
            currentData = result;
            
            document.getElementById('clusterControls').style.display = 'block';
            showAlert('info', '샘플 데이터가 로드되었습니다.');
        }
        
        function clearAll() {
            document.getElementById('topologyCanvas').innerHTML = `
                <div class="loading">
                    <h3>📡 북스터디 데이터를 불러오는 중...</h3>
                    <p>잠시만 기다려주세요</p>
                </div>
            `;
            document.getElementById('clusterControls').style.display = 'none';
            updateStats({ stats: { totalResponses: 0, totalKeywords: 0, clusterCount: 0 }, centerConcept: '-' });
            currentData = null;
        }
        
        function exportImage() {
            if (!currentData) {
                alert('먼저 데이터를 분석해주세요.');
                return;
            }
            
            // 간단한 이미지 저장 안내
            alert('스크린샷을 찍어서 저장하세요.\nWindows: Win + Shift + S\nMac: Cmd + Shift + 4');
        }
        
        function showAlert(type, message) {
            const existingAlert = document.querySelector('.alert');
            if (existingAlert && existingAlert.textContent !== existingAlert.querySelector('strong').textContent) {
                existingAlert.remove();
            }
            
            const alert = document.createElement('div');
            alert.className = `alert alert-${type === 'success' ? 'success' : 'info'}`;
            alert.innerHTML = message;
            
            document.querySelector('.control-panel').appendChild(alert);
            
            setTimeout(() => {
                if (alert.parentNode) {
                    alert.remove();
                }
            }, 5000);
        }
    </script>
</body>
</html>